<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="This is the Owen programming language specification.">
        <meta name="keywords" content="Owen, programming language, specification, reference">
        <title>Owen specification 0.18.0</title>
        <link rel="icon" type="image/x-icon" href="images/owen.png" />
        <link rel="stylesheet" type="text/css" href="css/global.css">
    </head>
    <body>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="specification.html">Spec</a></li>
                <li><a href="https://github.com/pawwkm/owen">Repo</a></li>
            </ul>
        </nav>
        <main>
            <section>
                <header>
                    <h1>Owen specification 0.18.0</h1>
                    <p>
                        The specification is versioned using <a href="https://semver.org/spec/v2.0.0.html">Semver 2.0</a>.
                        <a href="http://bford.info/pub/lang/peg.pdf">Parser Expression Grammar</a>
                        is used to define the syntax. Files are encoded
                        using UTF-8 and uses the <b>.owen</b> extension.
                    </p>
                </header>

                <p>
                    The design guidlines are:
                </p>
                
                <ul>
                    <li>Control &gt; language safety.</li>
                    <li>
                        Compiler/spec simplicity &gt; programmer convenience unless 
                        really, really convenient.
                    </li>
                    <li>Compiler/spec simplicity &gt; backwards compatibility.</li>
                    <li>
                        If there is no resonable default from the spec's perspective
                        it is the programmer's decision.
                    </li>
                </ul>
                
                <blockquote>
                    <p>
                        What remains unsaid is mostly left so intentionally, either 
                        because it is derivable from stated rules of the language, 
                        or because it would unnecessarily restrict the freedom of 
                        implementors.
                    </p>
                    <footer>
                         Niklaus Wirth in <cite><a href="https://people.inf.ethz.ch/wirth/Oberon/Oberon07.Report.pdf">Oberon7 report</a></cite>
                    </footer>
                </blockquote>

                <h1>1. Files</h1>
                <pre><code>file ← whitespace
       namespace_directive
       use_directive*
       declaration*

namespace_directive ← namespace upper_case_identifier
use_directive ← use upper_case_identifier

declaration ← public? ( function_declaration
                      / external_function_declaration
                      / proposition_declaration
                      / compound_declaration
                      / enumeration_declaration
                      / version_declaration)

upper_case_identifier ← [A-Z][a-z0-9]* (_[A-Z][a-z0-9]*)* whitespace
lower_case_identifier ← !keyword [a-z][a-z0-9]* (_[a-z][a-z0-9]*)* whitespace
keyword ← namespace
        / use
        / public
        / external
        / function
        / input
        / output
        / end
        / if
        / else
        / for
        / while
        / break
        / continue
        / structure
        / proposition
        / enumeration
        / of
        / size
        / union
        / return
        / true
        / false
        / assert
        / null
        / generalize
        / version
        
namespace ← 'namespace' whitespace
use ← 'use' whitespace
public ← 'public' whitespace
external ← 'external' whitespace
function ← 'function' whitespace
input ← 'input' whitespace
output ← 'output' whitespace
end ← 'end' whitespace
if ← 'if' whitespace
else ← 'else' whitespace
for ← 'for' whitespace
while ← 'while' whitespace
break ← 'break' whitespace
continue ← 'continue' whitespace
structure ← 'structure' whitespace
proposition ← 'proposition' whitespace
enumeration ← 'enumeration' whitespace
of ← 'of' whitespace
size ← 'size' whitespace
union ← 'union' whitespace
return ← 'return' whitespace
true ← 'true' whitespace
false ← 'false' whitespace
assert ← 'assert' whitespace
null ← 'null' whitespace
generalize ← 'generalize' whitespace
version ← 'version' whitespace

whitespace ← (' ' / '\n' / comment)*
comment ← '//' (!'\n' .)* '\n'?</code></pre>

                <p>
                    The <span class="rule">namespace_directive</span> specifies that
                    all <span class="rule">declaration</span>s in the
                    <span class="rule">file</span> are in the given name
                    space. The <span class="rule">use_directive</span> and
                    <span class="rule">namespace_directive</span> makes all the
                    <span class="keyword">public</span> <span class="rule">declaration</span>s
                    in the given name space available to the
                    <span class="rule">file</span>. The order in which <span class="rule">file</span>s
                    are compiled is undefined. It is allowed to have multiple symbols in scope with the 
                    same name. Ambiguous references is an error.
                </p>
                
                <h1>2. Declarations</h1>
                <h2>2.1 Functions</h2>
                <pre><code>function_declaration ← function_signature
                           statements
                       end

function_signature ← function lower_case_identifier
                         (generalize upper_case_identifiers)?
                         (input arguments)?
                         (output types)?

upper_case_identifiers = upper_case_identifier (comma upper_case_identifier)*
arguments ← type lower_case_identifier (comma type lower_case_identifier)*</code></pre>

                <p>
                    Declares a function named <span class="rule">lower_case_identifier</span>.
                    <span class="keyword">input</span>
                    defines a list of arguments that a caller must pass to the
                    function. The <span class="rule">arguments</span> are in the
                    same scope as <span class="rule">statements</span> and must have
                    unique names. Functions can be overloaded with a different order
                    of <span class="keyword">input</span> types. The 
                    <span class="keyword">output</span> list is the
                    types of the values that the function returns <b>in</b> the order
                    they are listed.
                </p>
                
                <p>
                    Functions defining <span class="keyword">output</span> must
                    end with a terminating statement. A terminating statements 
                    is either a <span class="rule">return_statement</span> or 
                    <span class="rule">if_statement</span> where the <span class="keyword">else</span> 
                    branch is present and all branches ends with terminating statements.
                </p>

                <h3>2.1.1. The main function</h3>
                <p>
                    The <i>main</i> function is the entry point of the program. It
                    is the entry point of the program. The return type of main must
                    be <span class="type">I32</span>.
                </p>

                <h3>2.1.2. Foreign function interface</h3>
                <pre><code>external_function_declaration ← external function_signature 
                                    utf8_string_literal
                                    utf8_string_literal</code></pre>
                
                <p>
                    Defines a reference to a C function in a library. The first
                    <span class="rule">utf8_string_literal</span> is the path to the library. 
                    The second <span class="rule">utf8_string_literal</span> is the function's name
                    in said library. Foreign functions cannot return multiple values.
                </p>

                <h2>2.2. Propositions</h2>
                <pre><code>proposition_declaration ← proposition
                              statements
                          end</code></pre>

                <p>
                    Propositions are nameless functions that returns no values. They
                    are run before the <i>main</i> function if they are included
                    using the <b>-propositions</b> command line argument.
                </p>

                <h2>2.3. Compounds</h2>
                <pre><code>compound_declaration ← (structure / union) upper_case_identifier
                           (generalize upper_case_identifiers)?
                            field*
                        end
 
field ← type lower_case_identifier</code></pre>

                <p>
                    <span class="rule">structure</span> <span class="rule">field</span>s
                    are laid out in memory as they are lexically declared. Padding may be 
                    inserted between fields. The size of the structure is the sum of its
                    <span class="rule">field</span>s and padding.
                </p>

                <p>
                    <span class="rule">union</span> <span class="rule">field</span>s
                    starts at the same address. The size of the union is the size
                    of the largest <span class="rule">field</span>.
                </p>
                
                <p>
                    <span class="rule">field</span> names must be unique within the 
                    <span class="rule">compound_declaration</span> and cannot have 
                    the same name as <span class="rule">compound_declaration</span>.
                </p>

                <h2>2.4. Enumerations</h2>
                <pre><code>enumeration_declaration ← enumeration upper_case_identifier of type
                              enumeration_constant*
                          end

enumeration_constant ← lower_case_identifier (assign integer_literal)?</code></pre>

                <p>
                    The <span class="rule">upper_case_identifier</span> after the <span class="rule">enumeration</span>
                    keyword is the name of the enumeration. The <span class="rule">type</span> of the enumeration must be either an 
                    <span class="type">IXX</span> or <span class="type">UXX</span>.
                </p>
                
                <p>
                    Each <span class="rule">enumeration_constant</span> must have an unique 
                    <span class="rule">lower_case_identifier</span> within the declaration.
                    If an <span class="rule">enumeration_constant</span> omits the
                    <span class="rule">integer_literal</span> then it is the value of
                    the last constant + 1. If the first constant omits the
                    <span class="rule">integer_literal</span> then its value is 0.
                    Every <span class="rule">enumeration_constant</span> must fit within 
                    the <span class="rule">type</span>.
                </p>

                <h2>2.5. Versions</h2>
                <pre><code>version_declaration ← version upper_case_identifier
                          declaration*
                      end</code></pre>

                <p>
                    Conditionally compiles <span class="rule">declaration</span>s
                    if the <span class="rule">upper_case_identifier</span> has been declared in
                    the command line. The <span class="rule">upper_case_identifier</span> is
                    not part of the program's scope.
                </p>

                <h1>3. Statements</h1>
                <pre><code>statements ← ( assignment_statement
             / expression_statement
             / if_statement
             / for_statement
             / while_statement
             / assert_statement
             / version_statement)*
             ( break_statement 
             / continue_statement
             / return_statement)?</code></pre>

                <p>
                    Each <span class="rule">statement</span> are executed in lexical
                    order.
                </p>

                <h2>3.1. Assignment statements</h2>
                <pre><code>assignment_statement ← expressions assignment_operator expressions
expressions ← expression (comma expression)*
assignment_operator ← ([+-*/&amp;|^%] / '&lt;&lt;' / '&gt;&gt;')? '=' whitespace</code></pre>

                <p>
                    Each <span class="rule">expression</span> on the left hand side must be addressable
                    and each <span class="rule">expression</span> on the right hand side must be the
                    same type as the one being assigned to unless the left hand side <span class="rule">expression</span>
                    is a pointer which can also be assigned <span class="keyword">null</span> or an address type of <span class="type">U64</span>.
                </p>

                <p>
                    If the operator is <code>=</code> and an <span class="rule">expression</span> on
                    the left hand side is an undefined identifier it is declared as
                    a variable of the same type as the assigned <span class="rule">expression</span>.
                </p>

                <p>
                    If the right hand <span class="rule">expressions</span> doesn't contain a <span class="rule">call_expression</span>
                    outputting multiple values then both lists must be equal in length. The left <span class="rule">expressions</span>
                    is being assigned from left to right.
                </p>

                <p>
                    If the right hand <span class="rule">expressions</span> contains a <span class="rule">call_expression</span>
                    outputting multiple values then it must be the only <span class="rule">expression</span> on the right hand side.
                    The <code>=</code> operator is the only one allowed in this case. The left hand side
                    <span class="rule">expressions</span> must have the same length as the amount of outputted values.
                </p>

                <p>
                    <code>x op= expression</code> is the same as <code>x = x op expression</code>.
                </p>

                <h2>3.2. Expression statements</h2>
                <pre><code>expression_statement ← expression</code></pre>

                <p>
                    The <span class="rule">expression</span> must be a <span class="rule">call_expression</span>.
                </p>

                <h2>3.3. If statements</h2>
                <pre><code>if_statement ← if (assignment_statement semicolon)? expression
                   statements
              (else if (assignment_statement semicolon)? expression
                   statements)*
              (else
                   statements)?
               end

semicolon ← ';' whitespace</code></pre>

                <p>
                    Each <span class="rule">expression</span> is evaluated in
                    lexical order until one is <span class="keyword">true</span>.
                    The statements following the <span class="rule">expression</span>
                    are then executed. If <span class="rule">expression</span>s
                    are <span class="keyword">false</span> and the else block is
                    defined then its statements are executed.
                </p>

                <p>
                    each <span class="rule">assignment_statement</span> is executed
                    before the following <span class="rule">expression</span>. The
                    declared variables are in the scope of all the following
                    <span class="rule">statements</span> in the
                    <span class="rule">if_statement</span>.
                </p>

                <h2>3.4. For statements</h2>
                <pre><code>for_statement ← for assignment_statement semicolon expression semicolon assignment_statement
                    statements
                end</code></pre>

                <p>
                    The first <span class="rule">assignment_statement</span> is executed before
                    the first iteration. The declared variables are scoped inside the loop.
                    The <span class="rule">expression</span> is the condition for
                    executing the <span class="rule">statements</span> which must
                    be <span class="keyword">true</span>. The second
                    <span class="rule">assignment_statement</span> is executed after each
                    iteration. The <span class="rule">break_statement</span> skips
                    execution of the second <span class="rule">assignment_statement</span>.
                </p>

                <h2>3.5. While statements</h2>
                <pre><code>while_statement ← while (assignment_statement semicolon)? expression
                      statements
                  end</code></pre>

                <p>
                    The <span class="rule">expression</span> must be of type of
                    <span class="type">Bool</span>. If the
                    <span class="rule">expression</span> is
                    <span class="keyword">true</span>, then the
                    <span class="rule">statements</span> are executed. After the
                    <span class="rule">statements</span> have executed, the
                    expression is evaluated again, and if
                    <span class="keyword">true</span> the
                    <span class="rule">statements</span> are executed again. This
                    continues until the expression is
                    <span class="keyword">false</span>. The
                    <span class="rule">assignment_statement</span> is executed before
                    the first iteration and declared the variables is in the same 
                    scope as <span class="rule">statements</span>.
                </p>

                <h2>3.6. Break statements</h2>
                <pre><code>break_statement ← break integer_literal?</code></pre>

                <p>
                    The <span class="rule">break_statement</span> stops the execution
                    of the innermost loop in which it is declared. Execution resumes
                    after the innermost loop.
                </p>
                
                <p>
                    <span class="rule">integer_literal</span> is implicitly 1. 
                    if it is 2 it means break out of the second most inner loop 
                    and so on.
                </p>
                
                <h2>3.7. Continue statements</h2>
                <pre><code>continue_statement ← continue integer_literal?</code></pre>

                <p>
                    The <span class="rule">continue_statement</span> begins the 
                    next iteration of the innermost loop in which it is declared.
                </p>
                
                <p>
                    <span class="rule">integer_literal</span> is implicitly 1. 
                    if it is 2 it means break out of the second most inner loop 
                    and so on.
                </p>

                <h2>3.8. Return statements</h2>
                <pre><code>return_statement ← return expressions?</code></pre>

                <p>
                    Returns the control the function that called the one that
                    contains the return statement. If the function containing the
                    return statement doesn't specify any output, then the statement
                    cannot specify any <span class="rule">expressions</span> to
                    return and the function may omit the statement entirely. Since
                    in that case the control is returned to the caller after the
                    last statement. If <span class="keyword">output</span> is
                    defined, then all code paths must have a return statement with
                    expressions of the same type in the same order as declared by
                    <span class="keyword">output</span>.
                </p>

                <h2>3.9. Assert statements</h2>
                <pre><code>assert_statement ← assert expression</code></pre>

                <p>
                    The <span class="rule">expression</span> must be type of
                    <span class="type">Bool</span>. If the expression is
                    <span class="keyword">true</span>, then nothing happens. If the
                    <span class="rule">expression</span> is
                    <span class="keyword">false</span>, a description of the failing
                    assertion is given. If the assertion is in a function the
                    program stops, but if the assertion is in a proposition the
                    current proposition stops and the next starts executing.
                </p>

                <h2>3.10. Version statements</h2>
                <pre><code>version_statement ← version upper_case_identifier
                        statements
                    end</code></pre>

                <p>
                    Works the same way as Version Declarations but for
                    <span class="rule">statements</span>s instead.
                </p>

                <h1>4. Expressions</h1>
                <pre><code>expression ← logical_or_expression</code></pre>

                <p>
                    <span class="rule">logical_or_expression</span> has the lowest precedence
                    and <span class="rule">postfix_expression</span> has the highest precedence.
                    The right hand side of a binary expression must be of the same type as the
                    left hand side and the left hand side can only be a primitive type.
                </p>

                <p>
                    Operators are left associative unless noted otherwise.
                    Overflow and underflow is only checked for literals.
                </p>
                
                <p>
                    Variables, fields, pointers and <span class="rule">array_index_expression</span>s are addressable.
                </p>

                <h2>4.2. Logical or expressions</h2>
                <pre><code>logical_or_expression ← logical_and_expression ('||' whitespace logical_and_expression)*</code></pre>

                <p>
                    Both operands must be type of <span class="type">Bool</span>.
                    The type of the <span class="rule">logical_or_expression</span> is <span class="type">Bool</span>.
                    The right hand side is not executed if the left hand 
                    side is <span class="keyword">true</span>.
                    The <span class="rule">logical_or_expression</span> is <span class="keyword">true</span>
                    if either operand is <span class="keyword">true</span>.
                </p>

                <h2>4.3. Logical and expressions</h2>
                <pre><code>logical_and_expression ← relational_expression ('&amp;&amp;' whitespace relational_expression)*</code></pre>

                <p>
                    Both operands must be type of <span class="type">Bool</span>.
                    The type of the <span class="rule">logical_and_expression</span> is <span class="type">Bool</span>.
                    The right hand side is not executed if the left hand 
                    side is <span class="keyword">false</span>.
                    The <span class="rule">logical_and_expression</span> is <span class="keyword">true</span>
                    if both operands are <span class="keyword">true</span>.
                </p>

                <h2>4.4. Relational expressions</h2>
                <pre><code>relational_expression ← additive_expression (('==' / '!=' / '&lt;=' / '&gt;=' / '&lt;' / '&gt;') whitespace additive_expression)*</code></pre>
                
                <p>
                    The comparison results in a <span class="type">Bool</span>.
                    The operators are <code>==</code> (equal), <code>!=</code> (not equal),
                    <code>&lt;=</code> (less than or equal), <code>&gt;=</code> (greater than or equal),
                    <code>&lt;</code> (less than) and <code>&gt;</code> (greater than).
                </p>
                
                <p>
                    For <code>==</code> and <code>!=</code> both operands must be of the same primitive, pointer or enumeration type. 
                </p>
                
                <p>
                    For <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code> and <code>&gt;</code>
                    both operands must be of the same number, pointer or enumeration type. 
                </p>

                <h2>4.5. Additive expressions</h2>
                <pre><code>additive_expression ← multiplicative_expression (('+' / '-' / '|' / '^') whitespace multiplicative_expression)*</code></pre>

                <p>
                    If both operands are the same number type the type of the expression is the same as the operands.
                    <code>+</code> (add) and <code>-</code> (subtract) apply to any number type. <code>|</code> (bitwise or) and
                    <code>^</code> (bitwise xor) only applies to <span class="type">IXX</span> and <span class="type">UXX</span>.
                </p>

                <p>
                    If the left hand expression is a pointer type, the right hand expression is a 
                    <span class="type">UXX</span> type and the operator is either <code>+</code> or <code>-</code>
                    then <code>expression  * size of structure in bytes</code> is either added or subtracted.
                    The type of the additive expression is the same as the pointer type.
                </p>
                
                <p>
                    If both operands are the same enumeration type then <code>|</code> and <code>^</code> 
                    applies to the underlying value resulting in the same type as the operands.
                </p>
                
                <h2>4.6. Multiplicative expressions</h2>
                <pre><code>multiplicative_expression ← prefix_expression (('*' / '/' / '%' / '&amp;' / '&lt;&lt;' / '&gt;&gt;') whitespace prefix_expression)*</code></pre>

                <p>
                    If both operands are the same number type the type of the expression is the same as the operands.
                    <code>*</code> (multiply), <code>/</code> (divide), <code>%</code> (modulo), <code>&amp;</code> (bitwise and)
                    <code>&lt;&lt;</code> (left shift) and <code>&gt;&gt;</code> (right shift) applies to <span class="type">IXX</span> 
                    and <span class="type">UXX</span>. <code>*</code>, <code>/</code> and <code>%</code> also applies to <span class="type">FXX</span>.
                </p>

                <p>
                    If both operands are the same enumeration type then <code>&amp;</code> applies to the 
                    underlying value resulting in the same type as the operands.
                </p>

                <h2>4.7. Prefix expressions</h2>
                <pre><code>prefix_expression ← (not_expression / negate_expression / address_of_expression / dereference_expression)+ 
                  / postfix_expression</code></pre>

                <p>
                    Prefix operators are right associative.
                </p>

                <h3>4.7.1. Not expressions</h3>
                <pre><code>not_expression ← '!' whitespace prefix_expression</code></pre>

                <p>
                    Inverts a <span class="type">Bool</span>.
                </p>

                <h3>4.7.2. Negate expressions</h3>
                <pre><code>negate_expression ← '-' whitespace prefix_expression</code></pre>

                <p>
                    Negates the value of <span class="type">IXX</span> or <span class="type">FXX</span>.
                    The type of the expression is the same as the negated value.
                </p>

                <h3>4.7.3. Address of expressions</h3>
                <pre><code>address_of_expression ← '#' whitespace prefix_expression</code></pre>

                <p>
                    Takes the address of the <span class="rule">prefix_expression</span>.
                </p>

                <h3>4.7.4. Dereference expressions</h3>
                <pre><code>dereference_expression ← '@' whitespace prefix_expression</code></pre>

                <p>
                    Deferences the <span class="rule">prefix_expression</span>.
                    The type of the <span class="rule">dereference_expression</span>
                    is the same as what is the <span class="rule">prefix_expression</span>
                    is pointing to.
                </p>

                <h2>4.8. Postfix expressions</h2>
                <pre><code>postfix_expression ← primary_expression (field_access_expression / call_expression / array_index_expression)*</code></pre>

                <h3>4.8.1. Field access expressions</h3>
                <pre><code>field_access_expression ← dot lower_case_identifier
dot ← '.' whitespace</code></pre>

                <p>
                    The <span class="rule">lower_case_identifier</span> must be the name of a <span class="rule">field</span>.
                    The type of the expression is the same the <span class="rule">field</span>'s type.
                </p>

                <h3>4.8.2. Call expressions</h3>
                <pre><code>call_expression ← (left_angle_bracket types right_angle_bracket)?
                   left_parenthesis expressions? right_parenthesis</code></pre>

                <p>
                    The <span class="rule">expressions</span>' types must match the <span class="keyword">input</span> types
                    exactly. Optionally specify all generalized <span class="rule">types</span>. 
                </p>

                <h3>4.8.3. Array access expressions</h3>
                <pre><code>array_index_expression ← left_square_bracket expression right_square_bracket

left_square_bracket ← '[' whitespace
right_square_bracket ← ']' whitespace</code></pre>

                <p>
                    The indexed expression must be an array type. The type of <span class="rule">array_index_expression</span>
                    is a pointer to the element type.
                    The <span class="rule">expression</span> must be
                    an <span class="type">IXX</span>. The value must be within 0 and the size of the
                    dimension it is used to index into. Going out of bounds in Debug
                    mode the program is stopped and then a message is displayed to
                    the programmer explaining where the error occurred. Going out of
                    bounds in Release mode results in undefined behaviour.
                </p>

                <h2>4.9. Primary expressions</h2>
                <pre><code>primary_expression ← float_literal
                   / integer_literal
                   / boolean_literal
                   / unicode_code_point_literal
                   / utf8_string_literal
                   / array_literal
                   / compound_literal
                   / null_literal
                   / uninitialized_literal
                   / size_of_expression
                   / parenthesized_expression
                   / reference_expression
                   / enumeration_constant_access
                   / cast_expression</code></pre>

                <h3>4.9.1. Floating point literals</h3>
                <pre><code>float_literal ← [0-9]+ '.' [0-9]+</code></pre>

                <p>
                    Floating point values are defined as in IEEE 754. The specific
                    type of a literal is inferred.
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Range</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="type">F32</span></td>
                            <td>±1.18×10−38 to ±3.4×1038</td>
                        </tr>
                        <tr>
                            <td><span class="type">F64</span></td>
                            <td>±2.23×10−308 to ±1.80×10308</td>
                        </tr>
                    </tbody>
                </table>

                <h3>4.9.2. Integer literals</h3>
                <pre><code>integer_literal ← (binary_integer / decimal_integer / hexadecimal_integer)

binary_integer ← '0b' [01]+ ('_' [01]+)*
decimal_integer ← [0-9]+ ('_' [0-9]+)*
hexadecimal_integer ← '0x' hexadecimal_digit+ ('_' hexadecimal_digit+)*
hexadecimal_digit ← [0-9A-F]</code></pre>

                <p>
                    The specific type of a literal is inferred. The underscore doesn't 
                    change the value of the <span class="rule">integer_literal</span>.
                    Signed integers are stored using Two's complement.
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Min</th>
                            <th>Max</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="type">I8</span></td>
                            <td>-2<sup>7</sup></td>
                            <td>2<sup>7</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">I16</span></td>
                            <td>-2<sup>15</sup></td>
                            <td>2<sup>15</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">I32</span></td>
                            <td>-2<sup>31</sup></td>
                            <td>2<sup>31</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">I64</span></td>
                            <td>-2<sup>63</sup></td>
                            <td>2<sup>63</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">U8</span></td>
                            <td>0</td>
                            <td>2<sup>8</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">U16</span></td>
                            <td>0</td>
                            <td>2<sup>16</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">U32</span></td>
                            <td>0</td>
                            <td>2<sup>32</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">U64</span></td>
                            <td>0</td>
                            <td>2<sup>64</sup>-1</td>
                        </tr>
                    </tbody>
                </table>

                <h3>4.9.3. Boolean literals</h3>
                <pre><code>boolean_literal ← true / false</code></pre>

                <p>
                    <span class="rule">boolean_literal</span>s are type of
                    <span class="type">Bool</span>.
                </p>
                
                                
                <h3>4.9.4. Unicode code point literals</h3>
                <pre><code>unicode_code_point_literal ← "'" (unicode_escape_sequence / !"'" .) "'"
                
unicode_escape_sequence ← '\\u' hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit
                        / '\\U' hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit
                                hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit</code></pre>

                <p>
                    The <span class="rule">hexadecimal_digit</span>s in <span class="rule">unicode_escape_sequence</span>
                    represents a unicode code point in a <span class="type">U32</span>.
                </p>

                <h3>4.9.5. UTF-8 string literals</h3>
                <pre><code>utf8_string_literal ← '"' (unicode_escape_sequence / !'"' .)* '"' whitespace</code></pre>
                
                <p>
                    <span class="rule">utf8_string_literal</span>s are encoded as UTF-8 which are 
                    syntax sugar for <code>[]<span class="type">U8</span></code> and modifying them 
                    is undefined behaviour.
                </p>

                <h3>4.9.6. Array literals</h3>
                <pre><code>array_literal ← type (left_square_bracket right_square_bracket)+
              / dimension+ elements

dimension ← left_square_bracket integer_literal? right_square_bracket
elements ← left_curly_bracket element (comma element)* right_curly_bracket
element ← elements / expressions

left_curly_bracket ← '{' whitespace
right_curly_bracket ← '}' whitespace</code></pre>

                <p>
                    Dynamic arrays are defined by <span class="rule">type</span> and
                    dimensions.
                    Static arrays are defined by <span class="rule">dimension</span>s
                    and <span class="rule">elements</span>. Each <span class="rule">dimension</span>'s
                    <span class="rule">expression</span> must fit within <span class="type">U32</span>.
                    Arrays have a length and pointer field. Writing to a static array
                    is undefined behaviour.
                </p>

                <h3>4.9.7. Compound literals</h3>
                <pre><code>compound_literal ← upper_case_identifier (left_angle_bracket upper_case_identifier right_angle_bracket)?
                       field_initializer (comma field_initializer)*
                   end

field_initializer ← lower_case_identifier equal expression</code></pre>

                <p>
                    The <span class="rule">compound_literal</span>'s <span class="rule">upper_case_identifier</span> 
                    is the name of the compound to initialize. The <span class="rule">field_initializer</span>'s
                    <span class="rule">lower_case_identifier</span> is the name of the <span class="rule">field</span> to
                    initialize. The <span class="rule">expression</span> is the
                    value of the given <span class="rule">field</span>. The type of the <span class="rule">expression</span>
                    must match <span class="rule">field</span>'s type. 
                    
                    Fields that are not initialized have
                    undefined values.
                </p>

                <h3>4.9.8. Null literals</h3>
                <pre><code>null_literal ← null</code></pre>

                <p>
                    The value is what C dictates on the given platform.
                    Only pointer typed variables can be <span class="keyword">null</span>.
                </p>
                
                <h3>4.9.9. Uninitialized literals</h3>
                <pre><code>uninitialized_literal ← '---' whitespace type</code></pre>

                <p>
                    <span class="rule">uninitialized_literal</span> can only be used for declaring a variable 
                    and it must be the whole <span class="rule">expression</span> assigned to the variable. 
                    The actual value is undefined.
                </p>
                
                <h3>4.9.10. Size of expressions</h3>
                <pre><code>size_of_expression ← size of (type / expression)</code></pre>

                <p>
                    <span class="rule">size_of_expression</span> is substituted for an
                    <span class="rule">integer_literal</span> of the size of a <span class="rule">type</span>
                    or an <span class="rule">expression</span>'s type in bytes.
                </p>
                
                <h3>4.9.11. Parenthesized expressions</h3>
                <pre><code>parenthesized_expression ← left_parenthesis expression right_parenthesis</code></pre>
                
                <h3>4.9.12. Reference expressions</h3>
                <pre><code>reference_expression ← lower_case_identifier</code></pre>
                
                <p>
                    <span class="rule">reference_expression</span> refers to a
                    variable, <span class="keyword">input</span> or 
                    <span class="keyword">function</span> with the same name in scope. 
                    Each variable and <span class="keyword">input</span> must be used in a 
                    <span class="rule">reference_expression</span>.
                </p>
                
                <h3>4.9.13. Enumeration constant access expression</h3>
                <pre><code>enumeration_constant_access ← upper_case_identifier dot lower_case_identifier</code></pre>
                <p>
                    <span class="rule">upper_case_identifier</span> is the <span class="keyword">enumeration</span> type and 
                    <span class="rule">lower_case_identifier</span> is the <span class="rule">enumeration_constant</span> on 
                    said <span class="keyword">enumeration</span>. The type of the expression is the same the <span class="keyword">enumeration</span>
                    and the value of the expression is the same as the <span class="rule">enumeration_constant</span>.
                </p>

                <h3>4.9.14. Cast expressions</h3>
                <pre><code>cast_expression ← type left_parenthesis expression right_parenthesis</code></pre>

                <p>
                    Casts the <span class="rule">expression</span> to the <span class="rule">type</span>
                    then returns the value.
                </p>

                <h1>5. Types</h1>
                <pre><code>types ← type (comma type)*
type ← (left_square_bracket right_square_bracket / '#' whitespace)* (upper_case_identifier / function_type)

function_type ← function
                    (input types)?
                    (output types)?</code></pre>
            </section>
        </main>
    </body>
</html>