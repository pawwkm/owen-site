<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="This is the Owen programming language specification.">
        <meta name="keywords" content="Owen, programming language, specification, reference">
        <title>Owen specification 0.9.0</title>
        <link rel="icon" type="image/x-icon" href="images/owen.png" />
        <link rel="stylesheet" type="text/css" href="css/global.css">
    </head>
    <body>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="specification.html">Spec</a></li>
                <li><a href="https://github.com/pawwkm/owen">Repo</a></li>
            </ul>
        </nav>
        <main>
            <section>
                <header>
                    <h1>Owen specification 0.9.0</h1>
                    <p>
                        The specification is versioned using <a href="https://semver.org/spec/v2.0.0.html">Semver 2.0</a>.
                        <a href="http://bford.info/pub/lang/peg.pdf">Parser Expression Grammar</a>
                        is used to define the syntax. Files are encoded
                        using UTF-8 and uses the <b>.owen</b> extension.
                    </p>
                </header>

                <h1>1. Files</h1>
                <pre><code>file ← whitespace
       namespace_directive
       use_directive*
      (declaration / ctfe_expression / mixin_expression)*

namespace_directive ← namespace identifier
use_directive ← use identifier

declaration ← public? ( function_declaration
                      / external_function_declaration
                      / proposition_declaration
                      / compound_declaration
                      / enumeration_declaration
                      / version_declaration)

identifier ← !keyword [A-Za-z] [_A-Za-z0-9]* whitespace
keyword ← namespace
        / use
        / public
        / external
        / function
        / input
        / output
        / end
        / if
        / else
        / for
        / while
        / break
        / structure
        / proposition
        / enumeration
        / of
        / size
        / union
        / return
        / mixin
        / ctfe
        / true
        / false
        / assert
        / null
        / generalize
        / version
        / cast
        
namespace ← 'namespace' whitespace
use ← 'use' whitespace
public ← 'public' whitespace
external ← 'external' whitespace
function ← 'function' whitespace
input ← 'input' whitespace
output ← 'output' whitespace
end ← 'end' whitespace
if ← 'if' whitespace
else ← 'else' whitespace
for ← 'for' whitespace
while ← 'while' whitespace
break ← 'break' whitespace
structure ← 'structure' whitespace
proposition ← 'proposition' whitespace
enumeration ← 'enumeration' whitespace
of ← 'of' whitespace
size ← 'size' whitespace
union ← 'union' whitespace
return ← 'return' whitespace
mixin ← 'mixin' whitespace
ctfe ← 'ctfe' whitespace
true ← 'true' whitespace
false ← 'false' whitespace
assert ← 'assert' whitespace
null ← 'null' whitespace
generalize ← 'generalize' whitespace
version ← 'version' whitespace
cast ← 'cast' whitespace

dot ← '.' whitespace
whitespace ← (' ' / '\n' / comment)*
comment ← '//' (!'\n' .)* '\n'?</code></pre>

                <p>
                    The <span class="rule">namespace_directive</span> specifies that
                    all <span class="rule">declaration</span>s in the
                    <span class="rule">file</span> are in the given name
                    space. The <span class="rule">use_directive</span> and
                    <span class="rule">namespace_directive</span> makes all the
                    <span class="keyword">public</span> <span class="rule">declaration</span>s
                    in the given name space available to the
                    <span class="rule">file</span>. The order in which <span class="rule">file</span>s
                    are compiled is undefined. It is allowed to have multiple symbols in scope with the 
                    same name. Ambiguous references is an error.
                </p>

                <h2>1.1. Mixins</h2>
                <pre><code>mixin_expression ← mixin expression</code></pre>

                <p>
                    All mixins in all files are executed before any <span class="rule">ctfe_expression</span>
                    but after semantic analysis has completed. The order of 
                    files is undefined but the order of mixin execution within a
                    file is in lexical order. The 
                    <span class="rule">expression</span> must result in a 
                    <code>[]<span class="type">U8</span></code>. The array is 
                    injected a source code where mixin where declared. 
                    <span class="rule">mixin_expression</span>s are semantically
                    analyzed right before they are executed.
                </p>

                <h2>1.2. Ctfe</h2>
                <pre><code>ctfe_expression ← ctfe expression</code></pre>

                <p>
                    The order of which file executes their <span class="rule">ctfe_expression</span>s
                    are undefined but the order within a file is in lexical order. <span class="rule">ctfe_expression</span>s
                    are semantically analyzed right before they are executed. The value of the
                    <span class="rule">expression</span> is ignored.
                </p>

                <h1>2. Declarations</h1>
                <h2>2.1 Functions</h2>
                <pre><code>function_declaration ← functionSignature
                           statement*
                       end

functionSignature ← function identifier
                        (generalize identifiers)?
                        (input arguments)?
                        (output types)?

identifiers = identifier (comma identifier)*
arguments ← type identifier (comma type identifier)*
types ← type (comma type)*</code></pre>

                <p>
                    Declares a function named <span class="rule">identifier</span>.
                    <span class="keyword">input</span>
                    defines a list of arguments that a caller must pass to the
                    function. The <span class="rule">arguments</span> are in the
                    same scope as <span class="rule">statements</span> and must have
                    unique names. Functions can be overloaded with a different order
                    of <span class="keyword">input</span> types. The 
                    <span class="keyword">output</span> list is the
                    types of the values that the function returns <b>in</b> the order
                    they are listed.
                </p>

                <h3>2.1.1. The main function</h3>
                <p>
                    The <i>main</i> function is the entry point of the program. It
                    is the entry point of the program. The return type of main must
                    be <span class="type">I32</span>.
                </p>

                <h3>2.1.2. Foreign function interface</h3>
                <pre><code>external_function_declaration ← external functionSignature string</code></pre>
                <p>
                    Defines a reference to a C function in a library. The
                    <span class="rule">string</span> is the path to the library. Foreign functions cannot 
                    return multiple values.
                </p>

                <h2>2.2. Propositions</h2>
                <pre><code>proposition_declaration ← proposition
                              statement*
                          end</code></pre>

                <p>
                    Propositions are nameless functions that returns no values. They
                    are run before the <i>main</i> function if they are included
                    using the <b>-propositions</b> command line argument.
                </p>

                <h2>2.3. Compounds</h2>
                <pre><code>compound_declaration ← (structure / union) identifier
                           (generalize identifiers)?
                            field*
                        end
 
field ← type identifier</code></pre>

                <p>
                    <span class="rule">structure</span> <span class="rule">field</span>s
                    are laid out in memory as they are lexically declared. Padding may be 
                    inserted between fields. The size of the structure is the sum of its
                    <span class="rule">field</span>s and padding.
                </p>

                <p>
                    <span class="rule">union</span> <span class="rule">field</span>s
                    starts at the same address. The size of the union is the size
                    of the largest <span class="rule">field</span>.
                </p>
                
                <p>
                    <span class="rule">field</span> names must be unique within the 
                    <span class="rule">compound_declaration</span> and cannot have 
                    the same name as <span class="rule">compound_declaration</span>.
                </p>

                <h2>2.4. Enumerations</h2>
                <pre><code>enumeration_declaration ← enumeration identifier of type
                              enumeration_constant*
                          end

enumeration_constant ← identifier (assign integer_literal)?</code></pre>

                <p>
                    The <span class="rule">identifier</span> after the <span class="rule">enumeration</span>
                    keyword is the name of the enumeration. The type of the enumeration must be either an 
                    <span class="type">IXX</span> or <span class="type">UXX</span>.
                </p>
                
                <p>
                    Each <span class="rule">enumeration_constant</span> must have an unique 
                    <span class="rule">identifier</span> within the declaration.
                    If an <span class="rule">enumeration_constant</span> omits the
                    <span class="rule">integer_literal</span> then it is the value of
                    the last constant + 1. If the first constant omits the
                    <span class="rule">integer_literal</span> then its value is 0.
                    The type of the <span class="rule">enumeration_constant</span>s 
                    are inferred from the <span class="rule">type</span>.
                </p>

                <h2>2.5. Versions</h2>
                <pre><code>version_declaration ← version identifier
                          declaration*
                      end</code></pre>

                <p>
                    Conditionally compiles <span class="rule">declaration</span>s
                    if the <span class="rule">identifier</span> has been declared in
                    the command line. The <span class="rule">identifier</span> is
                    not part of the program's scope.
                </p>

                <h1>3. Statements</h1>
                <pre><code>statement ← assignment_statement
          / expression_statement
          / if_statement
          / for_statement
          / while_statement
          / break_statement
          / return_statement
          / assert_statement
          / version_statement</code></pre>

                <p>
                    Each <span class="rule">statement</span> are executed in lexical
                    order.
                </p>

                <h2>3.1. Assignment statements</h2>
                <pre><code>assignment_statement ← expressions assignment_operator expressions
expressions ← expression (comma expression)*
assignment_operator ← ([+-*/&amp;|^%] / '&lt;&lt;' / '&gt;&gt;')? '=' whitespace</code></pre>

                <p>
                    Each <span class="rule">expression</span> on the left hand side must be addressable
                    and each <span class="rule">expression</span> on the right hand side must be the
                    same type as the one being assigned to unless the left hand side <span class="rule">expression</span>
                    is a pointer which can also be assigned <span class="keyword">null</span> or an address type of <span class="type">U64</span>
                    which can be inferred.	
                </p>

                <p>
                    If the operator is <code>=</code> and an <span class="rule">expression</span> on
                    the left hand side is an undefined <span class="rule">identifier</span> it is declared as
                    a variable of the same type as the assigned <span class="rule">expression</span>.
                </p>

                <p>
                    If the right hand <span class="rule">expressions</span> doesn't contain a <span class="rule">call_expression</span>
                    outputting multiple values then both lists must be equal in length. The left <span class="rule">expressions</span>
                    is being assigned from left to right.
                    Number types are inferred from its defined <span class="rule">identifier</span>.
                </p>

                <p>
                    If the right hand <span class="rule">expressions</span> contains a <span class="rule">call_expression</span>
                    outputting multiple values then it must be the only <span class="rule">expression</span> on the right hand side.
                    The <code>=</code> operator is the only one allowed in this case. The left hand side
                    <span class="rule">expressions</span> must have the same length as the amount of outputted values.
                </p>

                <p>
                    <code>x op= expression</code> is the same as <code>x = x op expression</code>.
                </p>

                <h2>3.2. Expression statements</h2>
                <pre><code>expression_statement ← expression</code></pre>

                <p>
                    The <span class="rule">expression</span> must be a <span class="rule">call_expression</span>, 
                    <span class="rule">mixin_expression</span> or <span class="rule">ctfe_expression</span>.
                </p>

                <h2>3.3. If statements</h2>
                <pre><code>if_statement ← if (assignment_statement semicolon)? expression
                   statements?
              (else if (assignment_statement semicolon)? expression
                   statements?)*
              (else
                   statements?)?
               end

semicolon ← ';' whitespace</code></pre>

                <p>
                    Each <span class="rule">expression</span> is evaluated in
                    lexical order until one is <span class="keyword">true</span>.
                    The statements following the <span class="rule">expression</span>
                    are then executed. If <span class="rule">expression</span>s
                    are <span class="keyword">false</span> and the else block is
                    defined then its statements are executed.
                </p>

                <p>
                    each <span class="rule">assignment_statement</span> is executed
                    before the following <span class="rule">expression</span>. The
                    declared variables are in the scope of all the following
                    <span class="rule">statement</span>s in the
                    <span class="rule">if_statement</span>.
                </p>

                <h2>3.4. For statements</h2>
                <pre><code>for_statement ← for assignment_statement semicolon expression semicolon assignment_statement
                    statement*
                end</code></pre>

                <p>
                    The first <span class="rule">assignment_statement</span> is executed before
                    the first iteration. The declared variables are scoped inside the loop.
                    The <span class="rule">expression</span> is the condition for
                    executing the <span class="rule">statements</span> which must
                    be <span class="keyword">true</span>. The second
                    <span class="rule">assignment_statement</span> is executed after each
                    iteration. The <span class="rule">break_statement</span> skips
                    execution of the second <span class="rule">assignment_statement</span>.
                </p>

                <h2>3.5. While statements</h2>
                <pre><code>while_statement ← while (assignment_statement semicolon)? expression
                      statement*
                  end</code></pre>

                <p>
                    The <span class="rule">expression</span> must be of type of
                    <span class="type">Bool</span>. If the
                    <span class="rule">expression</span> is
                    <span class="keyword">true</span>, then the
                    <span class="rule">statements</span> are executed. After the
                    <span class="rule">statements</span> have executed, the
                    expression is evaluated again, and if
                    <span class="keyword">true</span> the
                    <span class="rule">statements</span> are executed again. This
                    continues until the expression is
                    <span class="keyword">false</span>. The
                    <span class="rule">assignment_statement</span> is executed before
                    the first iteration.
                </p>

                <h2>3.6. Break statements</h2>
                <pre><code>break_statement ← break</code></pre>

                <p>
                    The <span class="rule">break_statement</span> stops the execution
                    of the innermost loop in which it is declared. Execution resumes
                    after the innermost loop.
                </p>

                <h2>3.7. Return statements</h2>
                <pre><code>return_statement ← return expressions?</code></pre>

                <p>
                    Returns the control the function that called the one that
                    contains the return statement. If the function containing the
                    return statement doesn't specify any output, then the statement
                    cannot specify any <span class="rule">expressions</span> to
                    return and the function may omit the statement entirely. Since
                    in that case the control is returned to the caller after the
                    last statement. If <span class="keyword">output</span> is
                    defined, then all code paths must have a return statement with
                    expressions of the same type in the same order as declared by
                    <span class="keyword">output</span>. Number types are inferred
                    from the output.
                </p>

                <h2>3.8. Assert statements</h2>
                <pre><code>assert_statement ← assert expression</code></pre>

                <p>
                    The <span class="rule">expression</span> must be type of
                    <span class="type">Bool</span>. If the expression is
                    <span class="keyword">true</span>, then nothing happens. If the
                    <span class="rule">expression</span> is
                    <span class="keyword">false</span>, a description of the failing
                    assertion is given. If the assertion is in a function the
                    program stops, but if the assertion is in a proposition the
                    current proposition stops and the next starts executing.
                </p>

                <h2>3.9. Version statements</h2>
                <pre><code>version_statement ← version identifier
                        statement*
                    end</code></pre>

                <p>
                    Works the same way as Version Declarations but for
                    <span class="rule">statements</span>s instead.
                </p>

                <h1>4. Expressions</h1>
                <pre><code>expression ← logical_or_expression</code></pre>

                <p>
                    <span class="rule">logical_or_expression</span> has the lowest precedence
                    and <span class="rule">postfixExpression</span> has the highest precedence.
                    The right hand side of a binary expression must be of the same type as the
                    left hand side and the left hand side can only be a primitive type. The right
                    hand side can be inferred from the left hand side.
                </p>

                <p>
                    Operators are left associative unless noted otherwise.
                    Overflow and underflow is only checked for literals.
                </p>
                
                <p>
                    Variables, fields, pointers and <span class="rule">index_expression</span>s are addressable.
                </p>

                <h2>4.2. Logical or expressions</h2>
                <pre><code>logical_or_expression ← logical_and_expression ('||' whitespace logical_and_expression)*</code></pre>

                <p>
                    Both operands must be type of <span class="type">Bool</span>.
                    The type of the expression is <span class="type">Bool</span>.
                    Short circuits if the left hand side is <span class="keyword">true</span>.
                </p>

                <h2>4.3. Logical and expressions</h2>
                <pre><code>logical_and_expression ← relational_expression ('&amp;&amp;' whitespace relational_expression)*</code></pre>

                <p>
                    Both operands must be type of <span class="type">Bool</span>.
                    The type of the expression is <span class="type">Bool</span>.
                </p>

                <h2>4.4. Relational expressions</h2>
                <pre><code>relational_expression ← additive_expression (('==' / '!=' / '&lt;=' / '&gt;=' / '&lt;' / '&gt;') whitespace additive_expression)*</code></pre>
                
                <p>
                    The comparison results in a <span class="type">Bool</span>.
                    The operators are <code>==</code> (equal), <code>!=</code> (not equal),
                    <code>&lt;=</code> (less than or equal), <code>&gt;=</code> (greater than or equal),
                    <code>&lt;</code> (less than) and <code>&gt;</code> (greater than).
                </p>
                
                <p>
                    For <code>==</code> and <code>!=</code> both operands must be of the same primitive, pointer or enumeration type. 
                </p>
                
                <p>
                    For <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code> and <code>&gt;</code>
                    both operands must be of the same number, pointer or enumeration type. 
                </p>

                <h2>4.5. Additive expressions</h2>
                <pre><code>additive_expression ← multiplicative_expression (('+' / '-' / '|' / '^') whitespace multiplicative_expression)*</code></pre>

                <p>
                    If both operands are the same number type the type of the expression is the same as the operands.
                    <code>+</code> (add) and <code>-</code> (subtract) apply to any number type. <code>|</code> (bitwise or) and
                    <code>^</code> (bitwise xor) only applies to <span class="type">IXX</span> and <span class="type">UXX</span>.
                </p>

                <p>
                    If the left hand expression is a pointer type, the right hand expression is a 
                    <span class="type">UXX</span> type and the operator is either <code>+</code> or <code>-</code>
                    then <code>x * size of structure in bytes</code> is either added or subtracted.
                    The right hand expression is inferred as <span class="type">U64</span>.
                    The type of the additive expression is the same as the pointer type.
                </p>
                
                <p>
                    If both operands are the same enumeration type then <code>|</code> and <code>^</code> 
                    applies to the underlying value resulting in the same type as the operands.
                </p>
                
                <h2>4.6. Multiplicative expressions</h2>
                <pre><code>multiplicative_expression ← prefix_expression (('*' / '/' / '%' / '&amp;' / '&lt;&lt;' / '&gt;&gt;') whitespace prefix_expression)*</code></pre>

                <p>
                    If both operands are the same number type the type of the expression is the same as the operands.
                    <code>*</code> (multiply), <code>/</code> (divide), <code>%</code> (modulo), <code>&amp;</code> (bitwise and)
                    <code>&lt;&lt;</code> (left shift) and <code>&gt;&gt;</code> (right shift) applies to <span class="type">IXX</span> 
                    and <span class="type">UXX</span>. <code>*</code>, <code>/</code> and <code>%</code> also applies to <span class="type">FXX</span>.
                </p>

                <p>
                    If both operands are the same enumeration type then <code>&amp;</code> applies to the 
                    underlying value resulting in the same type as the operands.
                </p>

                <h2>4.7. Prefix expressions</h2>
                <pre><code>prefix_expression ← not_expression
                  / negate_expression
                  / size_of_expreassion
                  / cast_expression
                  / mixin_expression
                  / address_of_expression
                  / dereference_expression
                  / postfix_expression</code></pre>

                <p>
                    prefix operators are right associative.
                </p>

                <h3>4.7.1. Not expressions</h3>
                <pre><code>not_expression ← '!' whitespace postfix_expression</code></pre>

                <p>
                    Inverts a <span class="type">Bool</span>.
                </p>

                <h3>4.7.2. Negate expressions</h3>
                <pre><code>negate_expression ← '-' whitespace postfix_expression</code></pre>

                <p>
                    Negates the value of <span class="type">IXX</span> or <span class="type">FXX</span>.
                    The type of the expression is the same as the negated value.
                </p>

                <h3>4.7.3. Size of expressions</h3>
                <pre><code>size_of_expreassion ← size of type</code></pre>

                <p>
                    Results the size of the <span class="rule">type</span> as
                    a <span class="type">U32</span> in bytes.
                </p>

                <h3>4.7.4. Cast expressions</h3>
                <pre><code>castExpreassion ← cast left_parenthesis type right_parenthesis expression</code></pre>

                <p>
                    Casts the <span class="rule">expression</span> to the <span class="rule">type</span>
                    then returns the value.
                </p>

                <h3>4.7.5. Address of expressions</h3>
                <pre><code>address_of_expression ← '#' whitespace postfix_expression</code></pre>

                <p>
                    Takes the address of the <span class="rule">postfix_expression</span>.
                </p>

                <h3>4.7.6. Dereference expressions</h3>
                <pre><code>dereference_expression ← '@' whitespace postfix_expression</code></pre>

                <p>
                    Deferences the <span class="rule">postfix_expression</span>.
                    The type of the <span class="rule">dereference_expression</span>
                    is the same as what is the <span class="rule">postfix_expression</span>
                    is pointing to.
                </p>

                <h2>4.8. Postfix expressions</h2>
                <pre><code>postfix_expression ← primary_expression
                  / postfix_expression
                  ( 
                        dot_expression
                      / call_expression
                      / index_expression
                  )</code></pre>

                <h3>4.8.1. Dot expressions</h3>
                <pre><code>dot_expression ← dot postfix_expression</code></pre>

                <p>
                    The <span class="rule">postfix_expression</span> must be a 
                    member on a structure, enumeration or union. 
                </p>

                <h3>4.8.2. Call expressions</h3>
                <pre><code>call_expression ← (left_angle_bracket types right_angle_bracket)?
                   left_parenthesis expressions? right_parenthesis</code></pre>

                <p>
                    The <span class="rule">expressions</span> must match the <span class="keyword">input</span>
                    exactly. If there are multiple functions where numbers can be inferred from the 
                    <span class="keyword">input</span> it is an error. If the call is to a generic
                    function and not all types can be inferred from the input then <span class="rule">types</span>
                    must specify the function's <span class="keyword">generalize</span> list.
                </p>

                <h3>4.8.3. Index expressions</h3>
                <pre><code>index_expression ← left_square_bracket expression right_square_bracket

left_square_bracket ← '[' whitespace
right_square_bracket ← ']' whitespace</code></pre>

                <p>
                    The indexed expression must be an array type. The type of <span class="rule">index_expression</span>
                    is a pointer to the element type.
                    The <span class="rule">expression</span> must be
                    an <span class="type">IXX</span>. The value must be within 0 and the size of the
                    dimension it is used to index into. Going out of bounds in Debug
                    mode the program is stopped and then a message is displayed to
                    the programmer explaining where the error occurred. Going out of
                    bounds in Release mode results in undefined behaviour.
                </p>

                <h2>4.9. Primary expressions</h2>
                <pre><code>primary_expression ← float_literal
                   / integer_literal
                   / boolean_literal
                   / string_literal
                   / array_literal
                   / compound_literal
                   / null_literal
                   / identifier
                   / left_parenthesis expression right_parenthesis</code></pre>

                <h3>4.9.1. Floating point literals</h3>
                <pre><code>float_literal ← '-'? [0-9]+ '.' [0-9]+ ('f' ( '32' / '64' ))?</code></pre>

                <p>
                    Floating point values are defined as in IEEE 754. The specific
                    type of a literal is inferred when the type is known elsewhere
                    in the same context.
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Range</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="type">F32</span></td>
                            <td>±1.18×10−38 to ±3.4×1038</td>
                        </tr>
                        <tr>
                            <td><span class="type">F64</span></td>
                            <td>±2.23×10−308 to ±1.80×10308</td>
                        </tr>
                    </tbody>
                </table>

                <h3>4.9.2. Integer literals</h3>
                <pre><code>integer_literal ← '-'? [0-9]+ (('i' / 'u') ( '8' / '16' / '32' / '64' ))?</code></pre>

                <p>
                    The specific type of a literal is inferred when the type is
                    known elsewhere in the same context.
                </p>

                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Min</th>
                            <th>Max</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="type">I8</span></td>
                            <td>-2<sup>7</sup></td>
                            <td>2<sup>7</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">I16</span></td>
                            <td>-2<sup>15</sup></td>
                            <td>2<sup>15</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">I32</span></td>
                            <td>-2<sup>31</sup></td>
                            <td>2<sup>31</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">I64</span></td>
                            <td>-2<sup>63</sup></td>
                            <td>2<sup>63</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">U8</span></td>
                            <td>0</td>
                            <td>2<sup>8</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">U16</span></td>
                            <td>0</td>
                            <td>2<sup>16</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">U32</span></td>
                            <td>0</td>
                            <td>2<sup>32</sup>-1</td>
                        </tr>
                        <tr>
                            <td><span class="type">U64</span></td>
                            <td>0</td>
                            <td>2<sup>64</sup>-1</td>
                        </tr>
                    </tbody>
                </table>

                <h3>4.9.3. Boolean literals</h3>
                <pre><code>boolean_literal ← true / false</code></pre>

                <p>
                    <span class="rule">boolean_literal</span>s are type of
                    <span class="type">Bool</span>.
                </p>

                <h3>4.9.4. String literals</h3>
                <pre><code>string_literal ← '"' (escapeSequence / !'"' .) '"' whitespace

escapeSequence ← '\\' hex hex hex hex
hex ← [0-9a-f]</code></pre>

                <p>
                    Strings are encoded as UTF-8. A string literal is converted into
                    an <code>[]<span class="type">U8</span></code>. The
                    <span class="rule">hex</span>s in <span class="rule">escapeSequence</span>
                    represents a unicode code point.
                </p>

                <h3>4.9.5. Array literals</h3>
                <pre><code>array_literal ← type (left_square_bracket right_square_bracket)+
              / dimension+ elements

dimension ← left_square_bracket expression? right_square_bracket
elements ← left_curly_bracket element (comma element)* right_curly_bracket
element ← elements / expressions

left_curly_bracket ← '{' whitespace
right_curly_bracket ← '}' whitespace</code></pre>

                <p>
                    Dynamic arrays are defined by <span class="rule">type</span> and
                    dimensions.

                    Static arrays are defined by <span class="rule">dimension</span>s
                    and <span class="rule">elements</span>. Each <span class="rule">dimension</span>'s
                    <span class="rule">expression</span> must be a static
                    <span class="type">UXX</span> which can be inferred to <span class="type">U32</span>.

                    Arrays have a length and pointer field. Writing to a static array
                    is undefined behaviour.
                </p>

                <h3>4.9.6. Compound literals</h3>
                <pre><code>compound_literal ← identifier (left_angle_bracket identifiers right_angle_bracket)?
                       fieldInitializer (comma fieldInitializer)*
                   end

fieldInitializer ← identifier equal expression</code></pre>

                <p>
                    The <span class="rule">compound_literal</span>'s <span class="rule">identifier</span> 
                    is the name of the compound to initialize. The <span class="rule">fieldInitializer</span>'s
                    <span class="rule">identifier</span> is the name of the <span class="rule">field</span> to
                    initialize. The <span class="rule">expression</span> is the
                    value of the given <span class="rule">field</span>. The type of the <span class="rule">expression</span>
                    must match <span class="rule">field</span>'s type. Number types are inferred from the type of the 
                    <span class="rule">field</span>.
                    
                    
                    Fields that are not initialized have
                    undefined values.
                </p>

                <h3>4.9.7. Null literals</h3>
                <pre><code>null_literal ← null</code></pre>

                <p>
                    The value is what C dictates on the given platform.
                    Only pointer typed variables can be <span class="keyword">null</span>.
                </p>

                <h1>5. Types</h1>
                <pre><code>type ← pointerToOrArray* (functionType / identifier)

functionType ← pointerTo+ function
                              (input types)?
                              (output types)?

pointerToOrArray ← pointerTo / (left_square_bracket right_square_bracket)
pointerTo ← '*' whitespace</code></pre>
            </section>
        </main>
    </body>
</html>